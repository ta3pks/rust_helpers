macro_rules! impl_for{
    ($(($t:ty,$t2:ty)),*) => {
        $(
        impl CastNumExt<$t> for $t2 {
            fn cast_as(self) -> $t {
                self as $t
            }
        }
    )*
    };
}
pub trait CastNumExt<T> {
    fn cast_as(self) -> T;
}

impl_for!(
    (u8, u16),
    (u8, u32),
    (u8, u64),
    (u8, u128),
    (u8, usize),
    (u8, i8),
    (u8, i16),
    (u8, i32),
    (u8, i64),
    (u8, i128),
    (u8, isize),
    (u8, f32),
    (u8, f64),
    (u16, u8),
    (u16, u32),
    (u16, u64),
    (u16, u128),
    (u16, usize),
    (u16, i8),
    (u16, i16),
    (u16, i32),
    (u16, i64),
    (u16, i128),
    (u16, isize),
    (u16, f32),
    (u16, f64),
    (u32, u8),
    (u32, u16),
    (u32, u64),
    (u32, u128),
    (u32, usize),
    (u32, i8),
    (u32, i16),
    (u32, i32),
    (u32, i64),
    (u32, i128),
    (u32, isize),
    (u32, f32),
    (u32, f64),
    (u64, u8),
    (u64, u16),
    (u64, u32),
    (u64, u128),
    (u64, usize),
    (u64, i8),
    (u64, i16),
    (u64, i32),
    (u64, i64),
    (u64, i128),
    (u64, isize),
    (u64, f32),
    (u64, f64),
    (u128, u8),
    (u128, u16),
    (u128, u32),
    (u128, u64),
    (u128, usize),
    (u128, i8),
    (u128, i16),
    (u128, i32),
    (u128, i64),
    (u128, i128),
    (u128, isize),
    (u128, f32),
    (u128, f64),
    (usize, u8),
    (usize, u16),
    (usize, u32),
    (usize, u64),
    (usize, u128),
    (usize, i8),
    (usize, i16),
    (usize, i32),
    (usize, i64),
    (usize, i128),
    (usize, isize),
    (usize, f32),
    (usize, f64),
    (i8, u8),
    (i8, u16),
    (i8, u32),
    (i8, u64),
    (i8, u128),
    (i8, usize),
    (i8, i16),
    (i8, i32),
    (i8, i64),
    (i8, i128),
    (i8, isize),
    (i8, f32),
    (i8, f64),
    (i16, u8),
    (i16, u16),
    (i16, u32),
    (i16, u64),
    (i16, u128),
    (i16, usize),
    (i16, i8),
    (i16, i32),
    (i16, i64),
    (i16, i128),
    (i16, isize),
    (i16, f32),
    (i16, f64),
    (i32, u8),
    (i32, u16),
    (i32, u32),
    (i32, u64),
    (i32, u128),
    (i32, usize),
    (i32, i8),
    (i32, i16),
    (i32, i64),
    (i32, i128),
    (i32, isize),
    (i32, f32),
    (i32, f64),
    (i64, u8),
    (i64, u16),
    (i64, u32),
    (i64, u64),
    (i64, u128),
    (i64, usize),
    (i64, i8),
    (i64, i16),
    (i64, i32),
    (i64, i128),
    (i64, isize),
    (i64, f32),
    (i64, f64),
    (i128, u8),
    (i128, u16),
    (i128, u32),
    (i128, u64),
    (i128, u128),
    (i128, usize),
    (i128, i8),
    (i128, i16),
    (i128, i32),
    (i128, i64),
    (i128, isize),
    (i128, f32),
    (i128, f64),
    (isize, u8),
    (isize, u16),
    (isize, u32),
    (isize, u64),
    (isize, u128),
    (isize, usize),
    (isize, i8),
    (isize, i16),
    (isize, i32),
    (isize, i64),
    (isize, i128),
    (isize, f32),
    (isize, f64),
    (f32, u8),
    (f32, u16),
    (f32, u32),
    (f32, u64),
    (f32, u128),
    (f32, usize),
    (f32, i8),
    (f32, i16),
    (f32, i32),
    (f32, i64),
    (f32, i128),
    (f32, isize),
    (f32, f64),
    (f64, u8),
    (f64, u16),
    (f64, u32),
    (f64, u64),
    (f64, u128),
    (f64, usize),
    (f64, i8),
    (f64, i16),
    (f64, i32),
    (f64, i64),
    (f64, i128),
    (f64, isize),
    (f64, f32)
);

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_cast() {
        let a: u8 = 1;
        let b: u16 = a.cast_as();
        assert_eq!(b, 1);
    }
}
